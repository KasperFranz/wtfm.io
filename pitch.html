<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

  <title>Write the F!@#$%^ Manual</title>

  <!-- styles -->
  <link rel="stylesheet" href="/css/normalize.css">
  <link rel="stylesheet" href="/css/typeplate.css">
</head>
<body>
  <h1>Write the F!@#$%^ Manual<br /><small>The Pitch<small></h1>

  <h2>Overview</h2>

  <h3>Topic</h3>

  Writing documentation sucks. Not writing documentation sucks more.

  From making a business case for incorporating documentation into the product development workflow to creating functional, test-driven documentation; Write The F!@#$%^ Manual is the handbook for learning how to write high quality documentation without sacrificing productivity (or sanity).

  <h3>Audience &amp; Purpose</h3>

  This book is targeted towards managers, professionals, and engineers who understand the importance of documentation, but don’t have the knowledge (or resources) needed to effectively work it into an existing product development lifecycle.

  Writing high-quality documentation takes time, but (much like unit testing) lacks the obvious benefits that come with feature development, and is often neglected in early-stage projects. With this book, the reader will receive the tools needed to effectively write technical documentation, and will provide specific examples of how documentation can be used to improve project reliability and developer productivity.

  <h3>Competition</h3>

  While there is a small handful of books available about technical writing as a general subject, there are none in wide circulation that are devoted to practical technical documentation (and its benefits) for software development teams. That said, while this topic is not easily found in print, individual subjects like code commenting best practices and documentation driven development are covered extensively in software development blogs and online periodicals.

  This book aims to collect and expand upon this wisdom in one cohesive source; providing examples, case studies, and best practices to encourage documentation as an essential step in the product development lifecycle, not a chore to be put off.

  <h2>Outline</h2>

  <h3>Introduction</h3>

  “Good Code Is Subjective, Documentation Is Not”

  Writing technical documentation is like going to the dentist; you know you’re supposed to do it, but you don’t really want to. The problem with writing documentation is that it takes time, which pulls away from the job of writing code. Unfortunately, this attitude bleeds into every corner of an organization, reinforcing phrases like “good code doesn’t need documentation” and ultimately resulting in an unmaintainable legacy codebase.

  This section will dispel the “code as documentation” myth, and make a business case for prioritizing technical documentation within the product development lifecycle.

  Specific points to be addressed:

  <ul>
    <li>Clear and understandable documentation reduces developer onboarding time, which in turn builds a more informed, more productive organization</li>
    <li>Documentation is a professional courtesy for the next developer who has to work with your code</li>
    <li>Documentation prevents “knowledge silos” - a situation where specific areas of a codebase are only maintained and understood by one engineer</li>
  </ul>

  As an aside, this is a great anecdote about how poor documentation can have dire consequences - https://www.reddit.com/r/talesfromtechsupport/comments/5u2yra/the_time_i_killed_an_entire_company/

  <h3>Part 1 What Documentation is (and What it is Not)</h3>

  The overarching theme of this section will address what methods of technical documentation are available and when to use them. These methods can be split into three main categories: code comments, an accompanying README file, and dedicated documentation. It is important to clarify here that, because each of these documentation methods serves a different purpose, many successful development projects take advantage of at least two of them (if not all three).

  <h4>Always Be Commenting</h4>

  While there are countless tools that add more value to code comments (these will be addressed in the Tools of the Trade section later), the main purpose of code comments is to explain how a particular piece of code works, and why it was written that way.

  A common mistake many junior developers make is to document what a piece of code does. This, unfortunately, doesn’t add any value because in most cases, what the code is doing is pretty self-evident. On the flip side, just because you can identify what a piece of code is doing, that doesn’t mean how it works or why it was written that way is obvious.

  <h4>Write a README</h4>

  A requirement under the GNU Coding Standards, a project’s README file should explain (at the very least) the minimum information necessary to utilize a software package. Thanks to the popularity of code hosting communities like GitHub, GitLab, and Bitbucket, the README file has a significant amount of visibility and power within most open source projects.

  Common README template:

  <ul>
    <li>Installation</li>
    <li>Configuration</li>
    <li>Requirements</li>
    <li>Examples</li>
    <li>Contributing</li>
    <li>Testing</li>
    <li>Licensing</li>
  </ul>

  <h4>When in Doubt, Branch Out</h4>

  What do you do when the documentation is too big to put in a README file? This section will answer that question by touching upon different solutions for separating technical documentation from the source code (many of the tools to accomplish this will be covered in more detail later on).

  This is a common problem, so we will be looking at the Laravel README and documentation as a case study on how to deal with it:

  <ul>
    <li>https://github.com/laravel/laravel/blob/master/readme.md</li>
    <li>https://laravel.com/docs/5.4</li>
  </ul>

  This type of documentation is also incredibly important to have when providing a tool for end users as well, even technical ones. While the purpose of this book is to discuss the overarching benefits of (and methods for) writing technical documentation, this will be an important point to discuss in this section as there are many instances where end users will not have (or want) access to code comments or README files.

  <h3>Part 2 Writing Not-Bad Documentation</h3>

  When I was in the 9th grade, I had an English teacher who taught me to always assume my reader is lazy, stupid, and mean. In other words, don’t use ten words when five will do, don’t use a big word when a small one still gets the point across, and above all else, avoid ambiguity. That piece of advice is particularly useful when dealing with technical writing, as it is painfully easy to confuse even the most advanced reader. This section will focus on applying those three reader traits to technical documentation.

  Keep It Simple, Stupid
  Keep documentation as short, simple, and unambiguous as possible. Writing documentation isn’t about writing, it’s about teaching. Viewed through this lense, it is much easier to explain how to use even the most advanced platforms in simple terms.
  As an aside, calling out specific examples of high-quality documentation will provide a lot of value (https://github.com/PharkMillups/beautiful-docs is a great source for this):
  Stripe - https://stripe.com/docs/api
  GitHub - https://developer.github.com/v3/
  Underscore.js - http://underscorejs.org/
  Twitter Bootstrap - https://getbootstrap.com/
  Quality over Quantity
  Quality over quantity is something most developers strive for. It’s not the amount of code you write, but how well that code works. This same standard should be applied to documentation as well. Commenting every line of code or going overboard with redundant examples doesn’t add any value and only serves to confuse the reader. Don’t document things that don’t need to be documented (avoid write-only documentation).
  TL;DR: Examples, Examples, Examples
  Clear examples illustrate complex concepts simply, and should be used heavily to clear up any ambiguity. In a nutshell, examples are the TL;DR of documentation. There’s an art to examples that must be addressed, however. Simply showing a code snippet isn’t enough. As with comments, the how and why must be explained. Comparing and contrasting good vs. bad examples will be especially helpful here.
  Inspiration - https://github.com/tldr-pages/tldr
  PART 3 MAKE DOCUMENTATION GREAT AGAIN
  Given the right approach, documentation can be so much more than just a brain dump of words and examples. This section will cover different ways in which documentation can be incorporated into the product development lifecycle and how it can be used to improve the quality and reliability of the codebase.
  README Driven Development
  README Driven Development is the process of writing the README for a project first. This is a great way to work out how to structure and build a project early on. Similarly to how test-driven development helps identify bugs that might not have been caught otherwise, README Driven Development helps identify usability issues long before they become a problem.
  Case Study: As the lead developer of the Printfection API (https://printfection.github.io/API-Documentation/), I pushed for a documentation-first approach to API design. This allowed the team to get on the same page with the exact usability and structure of the API before writing a single line of code. Once the architecture was agreed upon, we were able to build the API clients in tandem with the API itself, using the documentation as our blueprint, which gave us the ability to perfectly validate the API against the documentation.
  Test Driven Documentation
  The Printfection API case study touches on an interesting process called Test Driven Documentation. This method of documentation follows the same workflow as described in the case study, but rather than manually building API clients to match the documented specification, the documentation is automatically verified against the API alongside the rest of a project’s test suite. This process is most commonly seen with API documentation in conjunction with parseable documentation specifications like API Blueprint and Swagger (which will be covered in more detail below).
  A Case for Open Sourcing Documentation
  Everyone makes mistakes, and even the most well-documented project can have grammatical or logical errors in the documentation. While not a largely common practice, there is a big case to be made for open sourcing technical documentation. By empowering consumers to fix problems and add examples to your documentation, you can ensure a high level of accuracy and engage more deeply with your project’s community.
  PART 4 TOOLS OF THE TRADE
  While technical documentation is about educating stakeholders on the proper use of a feature set, there are a ton of tools that can make both writing and reading documentation easier. This section will detail tools (and tool categories) for automatically generating documentation, hosting well-designed and searchable documentation, and even touch upon the (surprisingly cool) world of API documentation languages.
  API Documentation Specifications
  Due to the inherent technical nature of APIs as a product, there is a strong emphasis on creating well-designed, highly accurate documentation. This has led to the creation of several description languages for API documentation, which deserve to be specifically called out.
  In this section, we will touch lightly upon the three major API documentation specification languages available today. It will be important to note that two of these specifications (RAML and Swagger) have their own dedicated API management platforms, but the focus will be specifically on their documentation languages.
  RAML - http://raml.org/
  Swagger - http://swagger.io/
  API Blueprint - https://apiblueprint.org/
  Generators
  Documentation generators are often used to parse structured comments within a project’s source code and output formatted documentation. My personal opinion of documentation generators is that they do for documentation what site builders do for web design. That said, when used properly, documentation generators can be an excellent way to ensure high maintainability of technical documentation with minimal effects on productivity.
  This section will touch upon a few languages (most likely PHP and Ruby, as they are what I have the most professional experience with), and provide examples of what the input and output of their popular documentation generators looks like.
  Design and Hosting
  While just about any standard web host or wiki can be used to host well-designed documentation, there are a ton of tools that have been built specifically with technical documentation in mind. Some platforms are aimed directly at API documentation (anything that accepts Swagger or API Blueprint specifications, for example), while others are more generic and simply encourage well-designed, searchable technical documentation (call out a few popular examples, https://github.com/PharkMillups/beautiful-docs is a great resource for this section as well):
  Read the Docs - https://readthedocs.org/
  ReadMe - https://readme.io/
  Slate - https://github.com/lord/slate
  While mentioning a few platforms is important, the value of this section will be in addressing the specific features to look for when choosing a documentation hosting platform (for example, searchabilty, privacy, syntax, etc).
